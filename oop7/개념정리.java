/*
1. 클라스와 객체
객체란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다.
메모리에서 사용하고자 하는 설계도가 클라스이다.

- 클라스는 객체를 만들기 위한 설계도이다.
- 클라스는 속성(객체가 가지는 고유한 데이터)과 기능을 포함하고 있다.
- 객체는 클라스를 이용해서 메모리에 생성된다.
- 클라스에 정의된 모든 속성, 모든 기능은 객체 생성한 후에만 사용할 수 있다.
- 생성된 객체의 모든 속성, 모든 기능에 접근하기 위해서는 그 객체를 참조하는 참조변수를 활용해야 한다.

2. 참조변수

- 클라스 타입의 변수다 (기본자료형 타입이 아니다.)
- 생성된 객체의 참조값(주소값)을 저장하고 있다.
- 보통은 new 연산자가 객체 생성 후 반환하는 참조값을 가지게 된다.
- 참조변수.속성명, 참조변수.메소드명() 과 같은 형식으로 객체의 속성, 기능을 사용한다.

3. 생성자가 실행되는 시점

- 생성자는 객체를 생성하는 new 연산자 다음에 표시한다 (반드시 new 연산자와 같이 사용된다.)
- 객체 생성 직후에 실행된다. 

4. 생성자의 역할 
객체 생성 시 초기화를 담당. 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다.

- 객체 생성 직후에 수행할 작업을 정의한다 (객체 생성작업에 개발자의 의도를 포함시킨다.)
	- 멤버변수의 초기화 작업
	- 리소스(자원) 연결 작업
	- 환경설정정보 로딩 작업

5. this

- 생성된 모든 객체가 묵시적으로 가지고 있는 속성
- this에는 생성된 객체 자기 자신을 참조하는 참조값을 가지고 있다.
- this.속성명, this.메소드명 의 형식으로 사용한다면 그 객체의 속성, 기능을 참조한다.

6.  메소드 중복정의(overloading)를 사용하는 이유

- 하나의 클라스안에 매개변수를 달리하는 같은 이름의 메소드를 여러 개 정의하는 것
  (매개변수 개수, 매개변수 타입, 매개변수 타입별 순서)
- 기능의 수행에 필요한 데이터의 개수, 타입만 다르고 처리 작업이 유사한 작업들은 
  같은 이름의 메소드로 정의함으로써 기능 수행에 일관성을 가지게 한다.

7. 은닉화를 시키는 방법

- 클라스에는 속성(데이터)과 기능이 정의되어 있다.
- 속성(데이터)의 무결성을 유지하기 위해서 데이터를 임의로 조작하는 것을 막아야 한다.
- 접근제한자(private)를 사용해서 속성에 대한 외부 접근을 차단하고, 대신 그 속성을 조회/조작하는 별도의 기능을 제공한다.

8. 상속을 사용하는 이유

이미 잘 개발된 클라스를 재사용해서 새로운 클라스를 만들기 때문에 코드의 중복을 줄여준다
클라스의 수정을 최소화시킬 수도 있다. 부모 클라스의 수정으로 모든 자식 클라스들의 수정 효과를 가져오기 때문에
유지 보수 시간을 최소화시켜준다.

- 코드의 중복을 줄일 수 있다.
- 같은 타입(부류)로 만들 수 있다 (상속을 받는다는 것은 상속받은 부모클라스와 같은 타입이 되는 것이다.)

9. 클라스의 형변환이란?

- 상속관계(구현관계)에 있는 클라스 간에만 형변환이 가능하다.
- 부모클라스 p = new 자식클라스(); // 자동형변환

10. 클라스의 형변환이 이루어지는 예

- class Parent{}
  class Child extends Parent{}

  Parent p = new Child(); // 자동 형변환
  Child c = (Child) p;    // 강제 형변환

11. 메소드 재정의(over riding)를 사용하는 이유

- 상속관계에 클라스에서 부모로부터 물려받은 메소드가 자신이 사용하기 적합하지 않을 때 
  똑같은 이름으로 기능을 재정의하는 것
 - 자식클라스들이 자신에게 특화된 기능을 구현할 때 같은 이름으로 구현하게 할 수 있다.
   (클라스는 달라도 사용법이 동일한 메소드를 가지게 된다.)


12. 부모 객체와 자식객체를 임의로 지정하고 super를 활용해서 그림으로 표현해보기

싱클턴 객체 - 프로그램이 수행되는 동안 단 하나만 존재하는 객체 
			  (프로그램 수행하는 동안 객체가 두 개 존재할 수 없다)

public - 전체공개 (같은 패키지, 다른 패키지)

protected - 패키지 공개 (같은 패키지), 상속 관계일때 다른 패키지에 공개

default - 패키지 공개 (같은 패키지)

private - 클라스 내부 공개

추상화 - 구체적인 구현이 없는 것, 추상화의 대상은 메소드다, 추상화의 대상은 상황에 따라 달라지는 부분(기능, 작업)이다.

추상화 이유 - 상황에 따라 달라지는 작업은 각각의 구현클라스에 구현을 위임한다.
			  구현(재정의)을 강제한다, 사용방법을 통일시킨다 (메소드의 구조가 동일하다.)
			  구현 부담을 줄여준다 (탬플릿 패턴)

추상 메소드 - 구현부가 없는 메소드다, abstract 키워드 선언되어 있다, 구현 클라스는 추상메소드를 보유할 수 없다.
			  만약 부모클라스로부터 추상메소드를 상속받았다면 반드시 재정의해야한다.

추상 클라스 - 추상메소드를 보유할 수 없다, abstract 키워드 선언되어 있다.
			  new 연산자를 사용해서 객체를 생성할 수 없다.

super() - 부모 객체의 생성자를 호출하는 메소드다.
		- 모든 객체의 생성자에는 부모객체의 기본 생성자를 호출하는 super(); 코드가 생성자의 첫 줄에 포함되어 있다.
		  개발자가 추가하지 않아도 컴파일러가 자동으로 추가한다 
		- 필요에 따라서 super(); 대신 super(매개변수값, 매개변수값, ...)를 사용할 수도 있다.

final 

final 변수타입 변수명 = 값;								<--- 값을 변경할 수 없다.
public final 리턴타입 메소드명(매개변수, ...) {...}		<--- 재정의 할 수 없다.
public final class 클라스명 {}							<--- 상속받을 수 없다.

인터페이스

- 규약, 명세, 스펙, 표준을 정의한다.
- 인터페이스는 상수와 추상메소드만 가진다 (자바 1.7 기준)
- 인터페이스를 구현한 구현클라스는 여러 종류가 존재할 수 있다.
  Mouse인터페이스를 구현한 OpticalMouse, BallMouse, ... 
- 동일한 인터페이스를 구현한 구현클라스는 사용방법이 동일한 클라스가 된다.
- 인터페이스를 구현한다는 것은 즉, 인터페이스에서 정의한 기능을 제공하는 클라스가 된다는 의미다.
- 인터페이스는 객체를 생성할 수 없다.
- 인터페이스 타입의 참조변수는 구현객체(인터페이스를 구현한 객체, 자식객체)를 담을 수 있다.
- 클라스는 하나 이상의 인터페이스를 구현할 수 있다.
- 인터페이스는 하나 이상의 다른 인터페이스를 상속받을 수 있다.
- 인터페이스를 활용하면 사용법이 동일한 객체를 만들게 할 수 있다.
- 인터페이스를 활용하면 클라스와 클라스간의 관계를 느슨하게 만들 수 있다.
- 인터페이스를 활용하면 프로그램의 확장성을 높일 수 있다.

API (Application Programming Interface)
- 라이브러리(프로그램 개발에 자주 사용되는 클라스 및 인터페이스 모음)
- 메뉴얼 (제공되는 라이브러리에 대한 사용법 혹은 사용법이 기술된 문제)

동등성 - 객체는 다르지만 같은 값을 가지는 객체
동일성 - 같은 객체

Object
- 배열을 포함한 모든 클라스의 부모 클라스다.
- Object클라스에 구현된 모든 메소드는 배열을 포함한 모든 객체에서 사용할 수 있다.
- 배열을 포함한 모든 객체는 Object 타입의 변수에 저장할 수 있다.
- 주요 메소드
	- boolean equals(Object other) : 동일한 객체인지 여부를 반환한다.
			- equals()를 호출한 객체와 other객체가 동일한 객체인지 확인한다.
			- String 클라스를 포함한 많은 클라스들은 그 객체가 가진 값이 같으면 
			  같은 객체로 판단하도록 equals()를 재정의해서 사용한다.
	- int hashCode() : 객체를 식별할 수 있는 정수값을 반환한다.
			- 동일한 객체는 해시코드값이 동일하다.
			- 두 객체의 해시코드값이 서로 다르면 그 객체들은 동일한 객체가 아니다.
	- hashCode()와 equals(Object other)의 재정의
			- 두 객체의 특정한 값이 같으면 같은 객체로 판단하도록 할 수 있다.
	- String toString() : 객체의 정보를 문자열로 반환한다.
			- "설계도의 전체이름@해시코드값"으로 구성된 문자열을 반환한다.
			- System.out.println(객체의 참조변수); 이 실행문을 실행하면, 그 객체의
			  toString() 메소드 실행한 결과가 출력된다.
			- String은 그 객체가 가진 "텍스트"가 반환되도록 toString()을 재정의했다
			- 사용자가 정의한 클라스 중에서 값을 담을 목적으로 작성한 클라스에는 그 객체가 가진
			  값을 쉽게 확인해보기 위해 toString()을 재정의한다.

	- Object clone() : 객체의 복제본을 만들어서 반환한다.
			- Cloneable 인터페이스를 구현한 객체만 복제가능한 객체가 된다.
			- 복제된 객체는 항상 Object타입으로 반환된다.
			- 복제대상 객체는 그 클라스에 객체를 복제하는 메소드를 제공해야 한다.

	- Class<?> getClass() : 객체의 설계도 정보를 담고 있는 Class객체를 반환한다.

Wrapper 클라스
	- 기본자료형 타입의 값을 저장하는 객체를 생성한다.
	- 용도
		- 기본자료형 타입의 값을 담는 박스다.
		- 기본자료형 타입의 값과 관련된 유용한 기능을 제공한다.

	- 박싱(Boxing), 언박싱(UnBoxing)
		박싱 - 기본자료형의 값을 Wrapper 객체를 생성해서 담는 것
				Integer a = new Integer(23);
				Integer a = new Integer("23");
				Integer a = Integer.valueOf("23");

		언박싱 - Wrapper객체에 저장된 기본자료형의 값을 꺼낸 것
				int b = a.intValue();

	- 오토박싱, 오토언박싱
		오토박싱 - 기본자료형 값을 직접 Wrapper 타입의 변수에 대입할 때 발생
				Integer a = 23;		// Integer a = new Integer(23);
		오토언박싱 - 기본자료형 타입의 변수에 Wrapper 객체를 대입할 때 발생
				int b = a;			// int b = a.intValue();

SimpleDateFormat
	- Date -> text : Date객체의 날짜/시간정보를 지정된 패턴의 텍스트로 변환한다.
	- text -> Date : 지정된 패턴으로 작성된 텍스트를 Date객체로 변환한다.

	- 패턴 문자
		y : 년
		M : 월 (1~12)
		d : 일 (1~31)		D : 일 (1~365)
		h : 시 (1~12)		H : 시 (0~23)
		m : 분 (0~59)
		s : 초 (0~59)		S : 밀리초
		a : 오전/오후(오전,오후)
		E : 요일(일, 월, 화, 수, 목, 금, 토)

	Date date = new Date();
	date --> "2016-11-29"

DecimalFormat
	- 숫자 -> text : 숫자(정수, 실수)를 지정된 패턴의 텍스트로 변환한다.
	- text -> 숫자 : 지정된 패턴으로 작성된 텍스트를 숫자로 변환한다.

	- 패턴 문자
		# : 십진수(빈자리를 0으로 채우지 않는다.)
		0 : 십진수(빈자리를 0으로 채운다.)
		. : 소수점
		- : 음수 기호
		, : 자리수 표시

	1000000 ---> 1,000,000

try {
		예외발생이 예상되는 실행문 ----1
		실행문					-------2
} catch(가로칠 예외 변수) {
	예외발생시 실행할 실행문 ----------3
}

1번 실행문에서 예외가 발생하지 않은 경우 : 1 -> 2 -> 4 -> ..../
1번 실해문에서 예외가 발생하는 경우 : 1 -> 3 -> 4 ....

finally 블록 : try 블록내에서 예외 발생하든지, 정상 실행되는지와 상관없이 반드시 실행해야 하는 실행문을 적는 곳이다.
				주로, 점유했던(사용했던) 자원을 반납하는 수행문을 적는다.

try {
	자원(리소스)와 연결하는 실행문; ----- 1

	예외발생이 예상되는 실행문;  ---------2
	실행문1;					----------3
	실행문2;						----- 4
	

 } catch(예외타입 변수명) {
		예외발생시 실행할 실행문;	------5
} finally {
		사용한 자원(리소스)를 해제하는 실행문; ----6
}

try {
		자원을 연결하는 실행문;
		예외 발생이 예상되지 않는 실행문;
		실행문1;
} finally {
		사용한 자원(리소스)를 해제하는 실행문; 
}
2번에서 예외발생하는 경우 : 1-> 2 -> 5 -> 6
2번에서 예외가 발생하지 않는 경우 : 1 -> 2 -> 3 -> 4-> 6

"12" --> 12
int no = Integer.parseInt("12");

"3.14" --> 3.14
double no = Double.parseDouble("3.14");

12 --> "12"
String s = String.valueOf(12);

3.14 --> "3.14"
String s = String.valueOf(3.14);

*/
